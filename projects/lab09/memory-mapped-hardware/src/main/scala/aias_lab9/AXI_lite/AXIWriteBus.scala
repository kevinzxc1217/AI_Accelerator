package aias_lab9.AXILite

import chisel3._
import chisel3.util._

/*
  including these signals (3 channels)
  1. write address channel
    AWADDR
    AWREADY
    AWVALID
  2. write data channel
    WDATA
    WREADY
    WVALID
  3. write response channel
    BRESP
    BREADY
    BVALID

  PS: read/valid signals is generated by Decoupled() syntax
 */

class writeMaster(val addrWidth: Int, val dataWidth: Int) extends Bundle {
  val writeAddr = Flipped(Decoupled(new AXILiteAddress(addrWidth)))
  val writeData = Flipped(Decoupled(new AXILiteWriteData(dataWidth)))
  val writeResp = Decoupled(UInt(2.W))
}
class writeSlave(val addrWidth: Int, val dataWidth: Int) extends Bundle {
  val writeAddr = Decoupled(new AXILiteAddress(addrWidth))
  val writeData = Decoupled(new AXILiteWriteData(dataWidth))
  val writeResp = Flipped(Decoupled(UInt(2.W)))
}

class AXIWriteBus(val mSlaves: Int, val addrWidth: Int, val dataWidth: Int, val addrMap: List[(UInt, UInt)])
    extends Module {
  val io = IO(new Bundle {
    val master = new writeMaster(addrWidth, dataWidth)
    val slave  = Vec(mSlaves, new writeSlave(addrWidth, dataWidth))
  })
  val write_port            = WireDefault(0.U(1.W))
  val write_port_reg        = RegInit(0.U(1.W))
  val write_addr_reg        = RegInit(0.U((addrWidth).W))
  val write_addr_reg_valid  = RegInit(false.B)
  val write_data_reg        = RegInit(0.U((dataWidth).W))
  val write_data_reg_valid  = RegInit(false.B)
  val write_data_reg_strb   = RegInit(0.U((dataWidth / 8).W))
  val slave_write_startAddr = Wire(Vec(mSlaves, UInt(addrWidth.W)))
  val slave_write_endAddr   = Wire(Vec(mSlaves, UInt(addrWidth.W)))

  for (i <- 0 until addrMap.length) {
    slave_write_startAddr(i) := addrMap(i)._1
    slave_write_endAddr(i)   := addrMap(i)._2
  }

  for (i <- 0 until mSlaves) {
    // initialize
    io.slave(i).writeData.valid     := false.B
    io.slave(i).writeData.bits.data := 0.U
    io.slave(i).writeData.bits.strb := 0.U
    io.slave(i).writeAddr.valid     := false.B
    io.slave(i).writeAddr.bits.addr := 0.U
    io.slave(i).writeResp.ready     := false.B

    // check whether slave_write_startAddr(i) <= io.master.writeAddr.bits.addr <= slave_write_endAddr
    // to find the target slave port
    when(
      slave_write_startAddr(i) <= io.master.writeAddr.bits.addr && io.master.writeAddr.bits.addr < slave_write_endAddr(
        i
      )
    ) {
      write_port := i.U // if true -> number of target slave port is i
    }.otherwise {
      write_port := 0.U
    }
  }

  // master port input initialization
  io.master.writeData.ready := false.B
  io.master.writeAddr.ready := false.B
  io.master.writeResp.valid := false.B
  io.master.writeResp.bits  := 0.U

  when(io.master.writeAddr.valid && write_addr_reg_valid === false.B) {
    write_port_reg       := write_port
    write_addr_reg       := io.master.writeAddr.bits.addr
    write_addr_reg_valid := true.B
  }.otherwise {
    write_addr_reg       := write_addr_reg
    write_addr_reg_valid := write_addr_reg_valid
  }

  when(write_addr_reg_valid) {
    io.master.writeAddr.ready := false.B
  }.otherwise {
    io.master.writeAddr.ready := true.B
  }

  when(io.master.writeData.valid && write_data_reg_valid === false.B) {
    write_data_reg_strb  := io.master.writeData.bits.strb
    write_data_reg       := io.master.writeData.bits.data
    write_data_reg_valid := true.B
  }.otherwise {
    write_data_reg       := write_data_reg
    write_data_reg_valid := write_data_reg_valid
    write_data_reg_strb  := write_data_reg_strb
  }

  when(write_data_reg_valid) {
    io.master.writeData.ready := false.B
  }.otherwise {
    io.master.writeData.ready := true.B
  }

  when(io.slave(write_port_reg).writeResp.valid && write_data_reg_valid === true.B) {
    io.master.writeResp.bits  := io.slave(write_port_reg).writeResp.bits
    io.master.writeResp.valid := true.B
    when(io.master.writeResp.ready) {
      io.slave(write_port_reg).writeResp.ready := true.B
      write_data_reg_valid                     := false.B
      write_addr_reg_valid                     := false.B
    }
  }.otherwise {
    io.master.writeResp.bits                 := 0.U
    io.slave(write_port_reg).writeResp.ready := false.B
    io.master.writeResp.valid                := false.B
  }

  io.slave(write_port_reg).writeAddr.bits.addr := write_addr_reg
  io.slave(write_port_reg).writeAddr.valid     := write_addr_reg_valid
  io.slave(write_port_reg).writeData.bits.data := write_data_reg
  io.slave(write_port_reg).writeData.bits.strb := write_data_reg_strb
  io.slave(write_port_reg).writeData.valid     := write_data_reg_valid
}
